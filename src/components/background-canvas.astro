---

---

<canvas id="background-canvas"></canvas>
<style>
  #background-canvas {
    display: block;
    position: absolute;
    inset: 0;
    z-index: -1;
    width: 100%;
    height: 100vh;
    opacity: 0;
    transition: opacity 1500ms ease-out;
  }
</style>
<script>
  import { THREE, resizeRendererToDisplaySize } from "../../utils/backgroundCanvas";
  const canvas = document.getElementById("background-canvas");
  let mouseX = 0;
  let mouseY = 0;

  document.addEventListener("mousemove", (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
  });

  const starBGCanvas = () => {
    const renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setClearColor(new THREE.Color("#1c1d24"));

    const fov = 50,
      aspect = 2,
      near = 5,
      far = 100;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.z = 5;

    const scene = new THREE.Scene();

    const textureLoader = new THREE.TextureLoader();
    const texture = textureLoader.load("/dot.svg");

    const particles = new THREE.Group();

    const particleCount = 1000;
    for (let i = 0; i < particleCount; i++) {
      const randomAngle = Math.random() * 360;
      const newMaterial = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        rotation: randomAngle,
      });

      const sprite = new THREE.Sprite(newMaterial);
      sprite.scale.set(0.1, 0.1, 1); // make the particle smaller
      sprite.position.set(
        (Math.random() - 0.5) * 15, // x
        Math.random() * 10 - 5, // y
        (Math.random() - 0.5) * 15, // z
      );

      sprite.material.rotation = randomAngle;

      particles.add(sprite);
    }

    scene.add(particles);

    const render = (time: number) => {
      time *= 0.001;

      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        // changing the camera aspect to remove the strechy problem
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      particles.position.x = mouseX * 0.0001;
      particles.position.y = mouseY * -0.0002;
      particles.rotation.y -= 0.0001;

      // update particles position and rotation
      particles.children.forEach((particle: any) => {
        particle.position.y += 0.0001; // move up
        particle.material.rotation += 0.0001;

        // if particle out of screen, reset to initial position
        if (particle.position.y > 5) {
          particle.position.y = -5;
        }
      });

      renderer.render(scene, camera);
      // loop

      requestAnimationFrame(render);
    };
    requestAnimationFrame(render);
  };

  document.addEventListener("astro:page-load", () => {
    if (canvas) {
      canvas.style.opacity = "1";
    }
    starBGCanvas();
  });

  window.addEventListener("beforeunload", () => {
    canvas?.remove();
  });
</script>
