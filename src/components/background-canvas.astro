---

---

<canvas id="background-canvas"></canvas>
<style>
  #background-canvas {
    display: block;
    position: absolute;
    inset: 0;
    z-index: -1;
    width: 100%;
    height: 100vh;
    opacity: 0;
    transition: opacity 1500ms ease-out;
  }
</style>
<script>
  import { THREE, resizeRendererToDisplaySize } from "../../utils/backgroundCanvas";

  const canvas = document.getElementById("background-canvas");
  document.addEventListener("DOMContentLoaded", () => {
    if (canvas) {
      canvas.style.opacity = "1";
    }
  });

  window.addEventListener("beforeunload", () => {
    canvas?.remove();
  });

  let mouseX = 0;
  let mouseY = 0;
  document.addEventListener("mousemove", (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
  });

  const starBGCanvas = () => {
    const renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setClearColor(new THREE.Color("#1c1d24"));
    // renderer.setClearColor(new THREE.Color("#7788f3"));

    const fov = 500,
      aspect = 2,
      near = 2,
      far = 5;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.z = 2;

    const scene = new THREE.Scene();
    // light source
    const color = 0xffffff,
      intensity = 1;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(-1, 2, 4);
    scene.add(light);

    const textureLoader = new THREE.TextureLoader();
    const texture = textureLoader.load("/dot.svg");

    const material = new THREE.SpriteMaterial({
      size: 0.05,
      map: texture,
      transparent: true,
      rotation: 0,
    });

    const particles = new THREE.Group();

    const particleCount = 100;
    for (let i = 0; i < particleCount; i++) {
      const sprite = new THREE.Sprite(material);
      sprite.position.set(
        (Math.random() - 0.5) * 15, // X 位置
        Math.random() * 10 - 5, // Y 位置
        (Math.random() - 0.5) * 5, // Z 位置
      );
      sprite.material.rotation = Math.random() * 10 * Math.PI * 2;
      particles.add(sprite);
    }

    scene.add(particles);

    const render = (time: number) => {
      time *= 0.001;
      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        // changing the camera aspect to remove the strechy problem
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      particles.position.x = mouseX * 0.0001;
      particles.position.y = mouseY * -0.0001;
      particles.rotation.y += 0.0001;

      // 更新粒子的旋转
      particles.children.forEach((particle: any) => {
        particle.material.rotation += 0.00001; // 控制旋转速度
      });

      // 更新粒子的位置，使它们向上移动
      particles.children.forEach((particle: any) => {
        particle.position.y += 0.001; // 向上移动

        // 如果粒子移出屏幕，则将其重置到初始位置
        if (particle.position.y > 5) {
          particle.position.y = -5;
        }
      });

      renderer.render(scene, camera);
      // loop
      requestAnimationFrame(render);
    };
    requestAnimationFrame(render);
  };

  starBGCanvas();
</script>
