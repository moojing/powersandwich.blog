---

---

<canvas id="background-canvas" transition:persist="background-canvas"></canvas>

<style>
  #background-canvas {
    display: block;
    position: absolute;
    inset: 0;
    z-index: -1;
    width: 100%;
    height: 100vh;
    opacity: 0;
    transition: opacity 1500ms ease-out;
  }
</style>
<script>
  import { THREE, resizeRendererToDisplaySize } from "../../utils/backgroundCanvas";
  const canvas = document.getElementById("background-canvas");
  let mouseX = 0;
  let mouseY = 0;

  document.addEventListener("mousemove", (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
  });

  let renderer: THREE.WebGLRenderer;

  const starBGCanvas = () => {
    renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setClearColor(new THREE.Color("#171717"));

    const fov = 75,
      aspect = window.innerWidth / window.innerHeight,
      near = 0.1,
      far = 1000;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.z = 3;

    const scene = new THREE.Scene();
    // scene.fog = new THREE.FogExp2(0x181818, 0.2);

    // light
    const light = new THREE.AmbientLight(0xffffff, 2);
    light.position.set(0, 0, 0);
    scene.add(light);

    const pointLight = new THREE.PointLight(0xffffff, 2);
    pointLight.position.set(0, 0, 0);
    scene.add(pointLight);

    // dot texture
    const textureLoader = new THREE.TextureLoader();
    const dotTexture = textureLoader.load("/dot.svg");

    const particlesGeometry = new THREE.BufferGeometry();
    const particleCount = 15000;

    const vertices = new Float32Array(particleCount);
    for (let i = 0; i < particleCount; i++) {
      vertices[i] = (Math.random() - 0.5) * 100;
    }

    const rotations = new Float32Array(particleCount);
    for (let i = 0; i < particleCount; i++) {
      rotations[i] = Math.random() * Math.PI * 2;
    }

    particlesGeometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3));
    particlesGeometry.setAttribute("rotation", new THREE.BufferAttribute(rotations, 1));

    const particlesMaterial = new THREE.PointsMaterial({
      map: dotTexture, // attach the texture to the material
      size: 0.2,
      transparent: true,
    });

    const stars = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(stars);

    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const animate = () => {
      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        // changing the camera aspect to remove the strechy problem
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      stars.position.x = mouseX * 0.0005;
      stars.position.y = mouseY * -0.0005;

      stars.rotation.x += scrollDelta * 0.002;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    };
    animate();
  };

  document.addEventListener("astro:page-load", () => {
    if (canvas) {
      canvas.style.opacity = "1";
    }
    if (!renderer) {
      starBGCanvas();
    }
  });

  window.addEventListener("beforeunload", () => {
    canvas?.remove();
  });
</script>
